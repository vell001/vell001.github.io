---
layout: post
title: "java 复习003"
date: 2014-04-13 09:12:04 +0800
updated: 2014-04-13 11:26:41 +0800
comments: true
categories: [java]
tags: [java,algorithm]
---
# java 复习003
	今天主要复习下数据结构的东西
	
## 树
1. 自平衡二叉查找树
	1. AVL树（高平衡树）([wiki](http://zh.wikipedia.org/wiki/AVL%E6%A0%91))
	![](/images/640px-AVLtreef.png)
		1. 特性：任何节点的两个子树的高度最大差别为一
		2. 时间复杂度：查找、插入和删除在平均和最坏情况下都是O（log n）
		
	2. 红黑树（对称二叉B树）([wiki](http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91))
	![](/images/640px-Red-black_tree_example.png)
		1. 特性：
			1. 节点是红色或黑色
			2. 根是黑色
			3. 所有叶子都是黑色（叶子是NIL节点）
			4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
			5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
		2. 优势： 
			1. 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，在高度上的理论上限允许红黑树在最坏情况下都是高效的
			2. 统计性能好
		3. 用途：用来构造关联数组（Map）和集合（Set）
	
2. B树
	1. B-树 ([百度百科](http://baike.baidu.com/view/1168762.htm))
	![](/images/B-tree_001.jpg)
		1. 特性：关键字分布在整颗树中，查找成功立即结束（区别于B+树）
		2. 性能：搜索效率等价于二分查找
		3. 用途：常用于文件引索系统
	
	2. B+树
	![](/images/B+_tree_001.jpg)
		1. 特性：每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点，查找成功也要跳到叶子节点才结束（区别于B-树）
		2. 用途：通常用于数据库和操作系统的文件系统中
	
	3. B*树
	![](/images/Bxx_tree_001.png)
		1. B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；

3. 键树
	1. 键树（数字查找树）
		1. 每条通往叶子节点的路径都是一个关键字符串
		
	2. trie树（字典树）
	![](/images/400px-Trie_example.png)
		1. 典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计
		2. 优点：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希表高
	
## 排序(java实现)
> 参见我的另一篇博客：[some-sort-algorithms](http://vblog.vell001.ml/2014/03/24/some-sort-algorithms.html)  
> 这里用java再实现一遍，代码比较多，放到另一篇博客去了：[some-sort-algorithms-java]()

## 查找
1. 二分查找
{% include_code lang:java java_review/BinarySearch.java %}

