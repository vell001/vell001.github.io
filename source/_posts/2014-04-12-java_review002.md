---
layout: post
title: "java 复习002"
date: 2014-04-12 09:12:04 +0800
updated: 2014-04-12 22:13:24 +0800
comments: true
categories: [java]
tags: [java,algorithm]
---
# java 复习002
	java东西太多了，我都有点小凌乱了，记得太没结构了  

## java内存回收机制：垃圾收集GC（Garbage Collection）
两种常用方法：  
1. 引用计数（早期使用）
	* 简介：**堆中对象**每次被**栈中引用**指向时，它的引用计数就加一，引用被删除时就减一；当引用计数为0的时候就被回收
	* 优点：操作简单，运行很快，在实时环境中比较有利
	* 缺点：容易出现循环引用（当A对象中有B对象的引用，B对象同时也存在A对象的引用时，AB对象的引用永远不可能为0，类似于*死锁*）

2. 引用遍历（现在使用）
	* 简介：从**栈中根引用**开始递归遍历可达对象，标记所有可达对象，然后回收没有标记的对象
	* 优点：不会出现循环引用，因为就算AB循环了，但是它们共同不可达，同样会被回收
	* 缺点：实现复杂，运行慢，运行时要打断应用程序工作

<!-- more -->
## java 异常机制
1. 异常：
> 程序出现异常，就是在当前环境下没有相应的处理程序可以调用时，程序会出现一种中断现象。
2. 处理机制简介：
	1. 出现异常时JVM会抛出一个异常类对象，如果程序中有相应的`try-catch`语句的话，会交给程序处理，如果没有的话直接交给JVM，JVM一般会在控制台打印出错信息。
	2. 存在`try-catch`的话，当`try`捕获到异常类对象时交给`catch`，匹配`catch`中定义的异常类，相同则执行`catch`语句块，找不见对应的`catch`的话就交给JVM了
	3. Error和Exception的区别：
		1. Error属于JVM一级的错误，可能和操作系统有关，程序无法控制和处理
		2. Exceptioan是开发者级的错误，大多数情况下可以由程序控制和处理，除了一些unchecked exception外，RuntimeException和其子类都是unchecked excception，如：NullPointerException，ClassCastException和IndexOutOfBoundsException

## 反射机制（Reflection）
1. 简介([百度百科](http://baike.baidu.com/view/3454964.htm))
	1. 在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义
	2. Java中，反射是一种强大的工具。它使您能够创建灵活的代码，这些代码可以在运行时装配
	3. 但需注意的是：如果使用不当，反射的成本很高。
	
2. 作用
	1. 通过类说明可以得到类的父类、实现的接口、内部类、构造函数、方法、属性
	2. 可以根据构造器实例化一个对象，唤起一个方法，取属性值，改属性值
	
3. 使用
	1. 得到一个类说明
``` java
Class cls=类.class;
Class cls=对象.getClass();
Class.forName("类路径");
```
	2. 得到一个方法并唤起它
``` java
Class cls=类.class;
Constructor cons=cls.getConstructor(new Class[]{String.class});
Object obj=cons.newInstance(new Object[]{"aaa"});
Method method=cls.getMethod("方法名",new Class[]{String.class,Integer.class});
method.invoke(obj,new Object[]{"aa",new Integer(1)});
```

## Struts2
1. struts2运行机制
![](/images/Struts2-Architecture.png)
2. 拦截器实现（动态代理，详见：[java_review001](http://vblog.vell001.ml/2014/04/11/java_review001.html)）
	1. 由`ActionInvocation`控制所有的拦截器
	2. 拦截器先执行`before`的代码，再调`ActionInvocation.invoke()`方法，最后执行`after`代码
	3. 对`ActionInvocation`中的`invoke`方法实现了递归调用
3. filter(过滤器)<->interaptor(拦截器)
	1. 拦截器是基于**JAVA反射机制**的，而过滤器是基于**函数回调**的。
	2. 过滤器依赖于Servlet容器，而拦截器不依赖于Servlet容器
	3. 拦截器只能对Action请求起作用，而过滤器可以对几乎所有的请求起作用。
	4. 拦截器可以访问Action上下文、值栈里的对象，而过滤器不能
	5. 在Action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。

## Spring
Spring在MVC模式中处于Controller位置
1. IoC(依赖注入)
	1. 简介：通常，服务代码需要先创建待使用的对象实例；而IoC模式中，创建待使用实例的任务由IoC容器来完成，服务代码直接使用实例
	2. 优势：
		1. 应用组件不需要在运行时自己寻找待使用对象，简化代码
		2. 只需在配置文件中管理组件依赖关系，不需要编写依赖关系代码
		3. 降低了组件间的耦合度，提高类的重用性，利于系统集成和配置
	3. 实现方法：反射机制
2. AOP(面向切面编程)
	1. 简介：在核心服务代码前后插入其它辅助服务代码，相当于将整个服务切成片了
	2. 优势：轻松实现辅助模块的装配
	3. 实现：动态代理(CGLIB),底层实现参考：[Spring AOP 实现原理与 CGLIB 应用](http://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/)
	
## PreparedStatement和Statement
1. PreparedStatement是参数化查询，使用`?`占位；Statement就是通用的SQL查询，凑SQL语句
2. PreparedStatement更快，因为SQL语句会预编译到数据库系统中，以后有相同的SQL请求不用再做**分析->编译->优化**的步骤了
3. SQL注入式攻击，指用户在填写查询信息时加入恶意的SQL代码，如`'; DROP TABLE users`
4. PreparedStatement能防止SQL注入式攻击，原因：PreparedStatement在参数传入前，它的SQL语句就在数据库中编译好了，执行时直接套用参数，所以参数中的SQL语句不会被数据库执行
5. 另一种防止SQL注入式攻击的方法：对传入字符串做转换（将单引号字符取代为连续2个单引号字符，因为连续2个单引号字符在SQL数据库中会视为字符中的一个单引号字符）

## 线程同步
1. 线程创建
	1. 实现`Runnable`接口，使用时需创建Thread对象，然后将实现了`Runnable`接口的对象传进去
	2. 直接继承`Thread`类(`Thread`本身已经实现了`Runnable`接口)，不用再创建Thread对象了，直接调用`start()`方法就启动线程了
	3. 尽量使用`Runnable`接口，因为接口的可扩展性好，它还可以继承一个别的类；而继承`Thread`类后不能再继承其它类了
	
2. 线程关闭
	1. 在父线程里使用`interrupt()`方法，在子线程里捕获`InterruptedExcepution`异常，调用`return`就结束子进程了（不太建议使用）
	2. 直接在父进程使用`stop()`方法，直接杀死子进程（太粗暴，不使用）
	3. 在子进程中添加`flag`属性，并给`run()`方法里加`while(flag)`语句，这样父进程只要将子进程的`flag`属性设为`false`，`run()`方法就结束了，整个进程也就结束了

3. 线程同步
	1. sleep
		1. `Thread.sleep(1000)`,表示当前线程睡眠1秒钟
		2. sleep时依然拥有着当前synchronized代码的锁，别的线程无法访问（区别于wait）
	2. 加锁(synchronized)
		1. 函数前：`public synchronized void doSomething(){}`
		2. 代码块：`synchronized(this){doSomething();}`
		3. 作用：当执行到`doSomething()`方法时锁定当前对象，不允许其他线程访问执行`doSomething()`函数，但可以执行别的**没有加锁**的代码；如果程序中有多个synchronized，则看谁先执行，后面的需要等待前面的执行完才能执行
	3. wait
		1. 使用前提是必须在synchronized代码内
		2. `this.wait()`,表示让执行当前synchronized代码的线程等待
		3. wait时，当前线程将进入阻塞状态，并且失去当前synchronized代码的锁（区别于sleep）
	4. notify
		1. 和wait相对应使用
		2. `this.notify()`,表示叫醒一个在当前synchronized代码`wait`的线程
		
> 参考至：  
> [http://www.cnblogs.com/laoyangHJ/articles/java_gc.html](http://www.cnblogs.com/laoyangHJ/articles/java_gc.html)
> [http://blog.csdn.net/kiss_vicente/article/details/7597700](http://blog.csdn.net/kiss_vicente/article/details/7597700)
